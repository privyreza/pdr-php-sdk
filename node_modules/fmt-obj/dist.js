
var lpadAlign = require('lpad-align')
var longest = require('longest')
var chalk = require('chalk')
var tsml = require('tsml')

var isPlainObj = function (o) { return o !== null && typeof o === 'object' && o.constructor === Object; }

var isLiteral = function (val) { return typeof val === 'boolean' || val === null || val === undefined; }

var annotate = function (formatter, keyword, val) { return tsml(["\n  ", "\n  ", "\n  ", "\n"], formatter.annotation(("[" + keyword + " ")), formatter.string(val), formatter.annotation(']')); }

var formatFunction = function (formatter, functionType, fn) { return annotate(formatter, functionType, fn.displayName || fn.name || 'anonymous'); }

var formatRef = function (formatter, path) { return annotate(formatter, 'References', '~' + path.join('.')); }

var formatCollapsedObject = function (formatter) { return tsml(["\n  ", "\n  ", "\n  ", "\n"], formatter.punctuation('('), formatter.string('collapsed'), formatter.punctuation(')')); }

var formatValue = function (formatter, val) {
  if (typeof val === 'number') {
    return formatter.number(val)
  }

  if (isLiteral(val)) {
    return formatter.literal(String(val))
  }

  var stringified = Object.prototype.toString.call(val)

  if (stringified === '[object Function]') {
    return formatFunction(formatter, 'Function', val)
  }

  if (stringified === '[object GeneratorFunction]') {
    return formatFunction(formatter, 'GeneratorFunction', val)
  }

  return tsml(["\n    ", "\n    ", "\n    ", "\n  "], formatter.punctuation('"'), formatter.string(val), formatter.punctuation('"'))
}

var isIterableWithKeys = function (val) { return isPlainObj(val) || Array.isArray(val); }

var createRefMap = function () {
  var map = new Map()

  return function (path, val, replacer) {
    if (!val || typeof (val) !== 'object') {
      return null
    }

    var ref = map.get(val)
    if (ref) { return replacer(ref) }
    map.set(val, path)
    return null
  }
}

var formatWithDepth = function (
  obj,
  formatter,
  ref
) {
  var lookupRef = ref.lookupRef;
  var path = ref.path;
  var depth = ref.depth;
  var offset = ref.offset;

  var keys = Object.keys(obj)
  var coloredKeys = keys.map(function (key) { return formatter.property(key); })
  var colon = ': '

  var parts = keys.map(function (key, i) {
    var nextPath = path.concat([key])
    var val = obj[key]

    var ref = lookupRef(
      nextPath,
      val,
      function (npath) { return formatRef(formatter, npath); }
    )

    var out = tsml(["\n      ", "\n      ", "\n    "], lpadAlign(coloredKeys[i], coloredKeys, offset), formatter.punctuation(colon))

    if (depth.curr > depth.max) {
      return out + formatCollapsedObject(formatter)
    }

    if (ref) {
      return out + ref
    }

    if (isIterableWithKeys(val)) {
      return out + formatWithDepth(val, formatter, {
        offset: offset + longest(keys).length + colon.length,
        depth: { curr: depth.curr + 1, max: depth.max },
        path: nextPath,
        lookupRef: lookupRef
      })
    } else {
      return out + formatValue(formatter, val)
    }
  })

  return '\n' + parts.join('\n')
}

var identityFormatter = [
  'punctuation',
  'annotation',
  'property',
  'literal',
  'number',
  'string'
].reduce(
  function (acc, prop) { return Object.assign({}, acc, ( obj = {}, obj[prop] = function (x) { return x; }, obj ))
    var obj;; },
  {}
)

var createFormatter = function (opts) {
  if ( opts === void 0 ) opts = {};

  var offset = opts.offset || 2
  var formatter = Object.assign({}, identityFormatter, opts.formatter)

  return function (obj, depth) {
    if ( depth === void 0 ) depth = Infinity;

    return formatWithDepth(obj, formatter, {
      depth: { curr: 0, max: depth },
      lookupRef: createRefMap(),
      path: [],
      offset: offset
    })
  }
}

var format = createFormatter({
  formatter: {
    punctuation: chalk.yellow,
    annotation: chalk.gray,
    property: chalk.green,
    literal: chalk.magenta,
    number: chalk.cyan,
    string: chalk.bold
  }
})

module.exports = format
module.exports.createFormatter = createFormatter

